# Android源码解读-无障碍服务

`本文基于Android T版本源码，分析无障碍服务相关的逻辑。`

## 简介

`AccessibilityService`的设计初衷是为了辅助有身体缺陷的群体使用Android应用，它的设计贯穿着Android的控件树`View`, `ViewGroup`, `ViewRootImpl`体系。借助于`system_server`进程的中转，能够注册Accessibility事件的客户端可以具备通过`system_server`提供的AccessibilityService来实现监听、操作其它应用视图的功能。这个功能十分强大，可以模拟用户的行为去操作其它APP，常常被用在自动化测试、微信抢红包、自动回复等功能实现中。

## 关键类说明

* AccessibilityService: APP端直接继承的类，本质上是Service，通过onBind获取匿名Binder对象实现通信
* IAccessibilityServiceClientWrapper: 用于和system_server通信的匿名Binder服务
* AccessibilityInteractionClient: 本质上是个binder服务，用于获取Node信息
* AccessibilityManagerService: 运行在system_server的实名binder服务，是整体的管理类
* AccessibilityInteractionConnection: 运行在被监测的APP端，提供查找、点击视图等服务
* AccessibilityManager: 运行在各个APP端，用于发送视图变化事件
* AccessibilityInteractionController: 具体视图查找、点击服务的中间控制器
* AccessibilityNodeProvider: 由客户端实现的视图节点内容提供者，最终操作的实现者

## 整体设计图

![](https://raw.githubusercontent.com/jiangxincode/PicGo/master/20230115163000.png)

## 实例代码

```java
public class AutoDismissService extends AccessibilityService {

    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (event == null) {
            return;
        }

        // 自动将android系统弹出的其它crash dialog取消
        dismissAppErrorDialogIfExists(event);
    }

    private void dismissAppErrorDialogIfExists(AccessibilityEvent event) {
        // WINDOW视图变化才进行对应操作
        if (event.getEventType() == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED && event.getPackageName().equals("android")) {
            // 查找带有"OK"字符的可点击Node
            AccessibilityNodeInfo nodeInfo = findViewByText("OK", true);
        if (nodeInfo != null) {
            // 查找到后执行点击操作
            performViewClick(nodeInfo);
        }
    }

    public AccessibilityNodeInfo findViewByText(String text, boolean clickable) {
        // 获取当前窗口父节点
        AccessibilityNodeInfo accessibilityNodeInfo = getRootInActiveWindow();
        if (accessibilityNodeInfo == null) {
            return null;
        }
        // 获取到满足字符要求的节点
        List<AccessibilityNodeInfo> nodeInfoList = accessibilityNodeInfo.findAccessibilityNodeInfosByText(text);
        if (nodeInfoList != null && !nodeInfoList.isEmpty()) {
            for (AccessibilityNodeInfo nodeInfo : nodeInfoList) {
                if (nodeInfo != null && (nodeInfo.isClickable() == clickable)) {
                    return nodeInfo;
                }
            }
        }
        return null;
    }

    public void performViewClick(AccessibilityNodeInfo nodeInfo) {
        if (nodeInfo == null) {
            return;
        }
        // 由下至上进行查询，直到寻找到可点击的节点
        while (nodeInfo != null) {
            if (nodeInfo.isClickable()) {
                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_CLICK);
                break;
            }
            nodeInfo = nodeInfo.getParent();
        }
    }
}
```

以上是一个典型的实现`AccessibilityService`的代码，主要涉及三点功能：

1. 当系统中有应用视图变化后，`onAccessibilityEvent`方法会自动被`system_server`调用
2. 通过`AccessibilityService`的`getRootInActiveWindow`与`findAccessibilityNodeInfosByText`方法，可以获取到节点信息
3. 通过`AccessibilityNodeInfo`的`performAction`方法，最终会在被监听APP中执行对应操作

本篇文章将会围绕着这三点主要功能进行源码分析，但是开始之前我们要先了解无障碍服务的启动过程。

## 无障碍服务(AccessibilityService)的启动流程

### 启动入口

当用户在`设置->辅助功能->无障碍`里面选择了开启或关闭一个辅助功能，会导致一些系统状态会变化；Accessibility APP的安装状态会以BroadcastReceivers的方式会通知状态改变；还有其他的一些状态改变。这些变化最终会调用到AMS的`onUserStateChangedLocked`方法。

```java
//frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java
    private void enableAccessibilityServiceLocked(ComponentName componentName, int userId) {
        ...
        if (userState.mEnabledServices.add(componentName)) {
            onUserStateChangedLocked(userState);
        }
    }

    private void onUserStateChangedLocked(AccessibilityUserState userState) {
        ...
        updateServicesLocked(userState);
        ...
    }

    private void updateServicesLocked(AccessibilityUserState userState) {
        ...
        for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {
            ...
            AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);
            ...
            if (userState.mEnabledServices.contains(componentName)
                    && !mUiAutomationManager.suppressingAccessibilityServicesLocked()) {
                if (service == null) {
                    service = new AccessibilityServiceConnection(userState, mContext, componentName,
                            installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,
                            this, getTraceManager(), mWindowManagerService,
                            getSystemActionPerformer(), mA11yWindowManager,
                            mActivityTaskManagerService);
                } else if (userState.mBoundServices.contains(service)) {
                    continue;
                }
                service.bindLocked();
            }
            ...
        }
        ...
    }
```

### 建立AMS到AS的通路

从上述代码中可以看到AMS为每个启动的无障碍服务建立了一个`AccessibilityServiceConnection`对象，调用其`bindLocked`方法：

```java
//frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityServiceConnection.java
    IAccessibilityServiceClient mServiceInterface;
    ...
    public void bindLocked() {
        ...
        try {
            ...
            if (mService == null && mContext.bindServiceAsUser(
                    mIntent, this, flags, new UserHandle(userState.mUserId))) {
                userState.getBindingServicesLocked().add(mComponentName);
            }
        }
        ...
    }

    @Override
    public void onServiceConnected(ComponentName componentName, IBinder service) {
        synchronized (mLock) {
            ...
            mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
            ...
        }
    }
```

```java
//frameworks/base/core/java/android/accessibilityservice/AccessibilityService.java

    @Override
    public final IBinder onBind(Intent intent) {
        return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
            ...
        }
    }
```

这里的`IAccessibilityServiceClient`实例是很重要的，后续作为`system_server`与无障碍服务的通信链路。

![](https://raw.githubusercontent.com/jiangxincode/PicGo/master/20230115163001.png)

### 建立AS到AMS的通路

之前`system_server`拿到了与无障碍服务的单向通信链路`IAccessibilityServiceClient`，然后马上将自己的实例传递给，而`AccessibilityServiceConnection`本身就是`IAccessibilityServiceConnection`的服务端，所以建立了一条之后AS到AMS的通路

![](https://raw.githubusercontent.com/jiangxincode/PicGo/master/20230115163002.png)

```java
//frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityServiceConnection.java
    IAccessibilityServiceClient mServiceInterface;

    @Override
    public void onServiceConnected(ComponentName componentName, IBinder service) {
        synchronized (mLock) {
            ...
            mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
            ...
            mMainHandler.sendMessage(obtainMessage(
                    AccessibilityServiceConnection::initializeService, this));
            ...
        }
    }

    private void initializeService() {
        IAccessibilityServiceClient serviceInterface = null;
        synchronized (mLock) {
            ...
            serviceInterface = mServiceInterface;
            ...
        }
        try {
            ...
            serviceInterface.init(this, mId, mOverlayWindowTokens.get(Display.DEFAULT_DISPLAY));
        }
        ...
    }
```

```java
//frameworks/base/core/java/android/accessibilityservice/AccessibilityService.java

    public static class IAccessibilityServiceClientWrapper extends IAccessibilityServiceClient.Stub
            implements HandlerCaller.Callback {
        public void init(IAccessibilityServiceConnection connection, int connectionId,
                IBinder windowToken) {
            Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,
                    connection, windowToken);
            mCaller.sendMessage(message);
        }

        @Override
        public void executeMessage(Message message) {
            ...
            case DO_INIT: {
                ...
                AccessibilityInteractionClient.getInstance(mContext).addConnection(
                                mConnectionId, connection, /*initializeCache=*/true);
                ...
            }
        }
    }
```

```java
//frameworks/base/core/java/android/view/accessibility/AccessibilityInteractionClient.java

    public static void addConnection(int connectionId, IAccessibilityServiceConnection connection,
            boolean initializeCache) {
        ...
        synchronized (sConnectionCache) {
            sConnectionCache.put(connectionId, connection);
            ...
        }
    }
```

## 无障碍事件(AccessibilityEvent)的分发流程

### 常见 AccessibilityEvent 事件种类

|序号|种类名称|触发时机|
|---|---|---|
|1|TYPE_VIEW_CLICKED|可点击的组件被点击|
|2|TYPE_VIEW_LONG_CLICKED|可点击的组件被长按|
|3|TYPE_VIEW_SELECTED|组件被选中|
|4|TYPE_VIEW_FOCUSED|组件获取到了焦点|
|5|TYPE_VIEW_TEXT_CHANGED|组件中的文本发生变化|
|6|TYPE_VIEW_SCROLLED|组件被滑动|
|7|TYPE_WINDOW_STATE_CHANGED|dialog等被打开|
|8|TYPE_NOTIFICATION_STATE_CHANGED|通知弹出|
|9|TYPE_WINDOW_CONTENT_CHANGED|组件树发生了变化|

这里以`TextView.setText`触发事件变化流程为例进行分析

### TextView.setText

应用组件状态发生变化

```java
//frameworks/base/core/java/android/widget/TextView.java
    ...
    private void setText(CharSequence text, BufferType type,
                         boolean notifyBefore, int oldlen) {
        ...
        if (a11yTextChangeType == AccessibilityUtils.TEXT) {
            notifyViewAccessibilityStateChangedIfNeeded(
                    AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT);
        }
        ...
    }
```

```java
//frameworks/base/core/java/android/view/View.java
    public void notifyViewAccessibilityStateChangedIfNeeded(int changeType) {
        ...
        final AccessibilityEvent event = AccessibilityEvent.obtain();
        event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
        event.setContentChangeTypes(changeType);
        sendAccessibilityEventUnchecked(event);
        ...
    }

    public void sendAccessibilityEventUnchecked(AccessibilityEvent event) {
        if (mAccessibilityDelegate != null) {
            mAccessibilityDelegate.sendAccessibilityEventUnchecked(this, event);
        } else {
            sendAccessibilityEventUncheckedInternal(event);
        }
    }

    public void sendAccessibilityEventUncheckedInternal(AccessibilityEvent event) {
        ...
        requestParentSendAccessibilityEvent(event);
        ...
    }

    // 此处交由TextView所在父View进行处理，为责任链模式，事件经过层层向上传递，最终交由ViewRootImpl进行处理
    private void requestParentSendAccessibilityEvent(AccessibilityEvent event) {
        ViewParent parent = getParent();
        if (parent != null) {
            getParent().requestSendAccessibilityEvent(this, event);
        }
    }
```

### ViewRootImpl.requestSendAccessibilityEvent

ViewRootImpl将事件派发到system_server

```java
//frameworks/base/core/java/android/view/ViewRootImpl.java
    public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event) {
        ...
        mAccessibilityManager.sendAccessibilityEvent(event);
        ...
    }
```

```java
//frameworks/base/core/java/android/view/accessibility/AccessibilityManager.java
    public void sendAccessibilityEvent(AccessibilityEvent event) {
        final IAccessibilityManager service;
        ...
        synchronized (mLock) {
            // 获取system_server的Accessibility实名服务
            service = getServiceLocked();
        }
        try {
            ...
            try {
                 // binder call 到服务端，进行事件分发中转
                service.sendAccessibilityEvent(dispatchedEvent, userId);
            }
            ...
        }
    }
```

被监控的客户端应用通过`IAccessibilityManager`与`system_server`建立通信链路（单向链路）

![](https://raw.githubusercontent.com/jiangxincode/PicGo/master/20230115163003.png)

### AccessibilityManagerService.sendAccessibilityEvent

system_server将事件分发到各个监听组件变化的Service

```java
//frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java

    // binder call 到服务端，触发事件派发
    public void sendAccessibilityEvent(AccessibilityEvent event, int userId) {
        if (dispatchEvent) {
            ...
            synchronized (mLock) {
                dispatchAccessibilityEventLocked(event);
            }
        }
    }

    private void dispatchAccessibilityEventLocked(AccessibilityEvent event) {
        notifyAccessibilityServicesDelayedLocked(event, false);
        notifyAccessibilityServicesDelayedLocked(event, true);
        mUiAutomationManager.sendAccessibilityEventLocked(event);
    }

    private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event,
            boolean isDefault) {
        try {
            AccessibilityUserState state = getCurrentUserStateLocked();
            for (int i = 0, count = state.mBoundServices.size(); i < count; i++) {
                AccessibilityServiceConnection service = state.mBoundServices.get(i);

                if (service.mIsDefault == isDefault) {
                    // 调用内部服务，以触发事件派发
                    service.notifyAccessibilityEvent(event);
                }
            }
        }
    }
```

`AccessibilityServiceConnection`是`AbstractAccessibilityServiceConnection`的子类，所以上述代码中的`service.notifyAccessibilityEvent(event)`的处理逻辑在`AbstractAccessibilityServiceConnection`中。

```java
//frameworks/base/services/accessibility/java/com/android/server/accessibility/AbstractAccessibilityServiceConnection.java

abstract class AbstractAccessibilityServiceConnection extends IAccessibilityServiceConnection.Stub
        implements ServiceConnection, IBinder.DeathRecipient... {
    public void notifyAccessibilityEvent(AccessibilityEvent event) {
        synchronized (mLock) {
            ...
            if ((mNotificationTimeout > 0)
                    && (eventType != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED)) {
                ...
                // 按照惯例，异步分发到客户端进行派发
                message = mEventDispatchHandler.obtainMessage(eventType);
            } else {
                message = mEventDispatchHandler.obtainMessage(eventType, newEvent);
            }
            message.arg1 = serviceWantsEvent ? 1 : 0;

            mEventDispatchHandler.sendMessageDelayed(message, mNotificationTimeout);
        }
    }

    //mEventDispatchHandler收到消息后调用notifyAccessibilityEventInternal方法
    private void notifyAccessibilityEventInternal(
            int eventType,
            AccessibilityEvent event,
            boolean serviceWantsEvent) {
        IAccessibilityServiceClient listener;
        synchronized (mLock) {
            listener = mServiceInterface;
        }
        try {
            ...
            listener.onAccessibilityEvent(event, serviceWantsEvent);
        }
        ...
    }
}
```

还记得之前在启动流程中说的IAccessibilityServiceClient其实就是`system_server`与无障碍服务的通信链路。

```java
//frameworks/base/core/java/android/accessibilityservice/AccessibilityService.java

    @Override
    public final IBinder onBind(Intent intent) {
        return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
            ...
            @Override
            public void onAccessibilityEvent(AccessibilityEvent event) {
                AccessibilityService.this.onAccessibilityEvent(event);
            }
            ...
        }
    }
```

### AccessibilityService.onAccessibilityEvent

```java
//frameworks/base/core/java/android/accessibilityservice/AccessibilityService.java

    // 抽象方法，模板模式，被系统主动调用
    public abstract void onAccessibilityEvent(AccessibilityEvent event);
```

后续逻辑就进入到无障碍服务应用的自由逻辑中了。无障碍服务应用接收到组件变化的事件，并可以选择做出相应的处理。

## 获取节点信息流程

在调用`findAccessibilityNodeInfosByText`之前，需要通过`getRootInActiveWindow`方法获取到父节点，才能通过调用父`AccessibilityNodeInfo`的方法进行其子节点信息查询

### AccessibilityService.getRootInActiveWindow

```java
//frameworks/base/core/java/android/accessibilityservice/AccessibilityService.java

    public AccessibilityNodeInfo getRootInActiveWindow(
            @AccessibilityNodeInfo.PrefetchingStrategy int prefetchingStrategy) {
        // 查找父节点的操作没有在自己的类中实现，而是交由了同一进程的Client管理类进行处理
        return AccessibilityInteractionClient.getInstance(this).getRootInActiveWindow(
                mConnectionId, prefetchingStrategy);
    }
```

```java
//frameworks/base/core/java/android/view/accessibility/AccessibilityInteractionClient.java

    public AccessibilityNodeInfo getRootInActiveWindow(int connectionId,
            @AccessibilityNodeInfo.PrefetchingStrategy int strategy) {
        return findAccessibilityNodeInfoByAccessibilityId(connectionId,
                AccessibilityWindowInfo.ACTIVE_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID,
                false, strategy, null);
    }

    public @Nullable AccessibilityNodeInfo findAccessibilityNodeInfoByAccessibilityId(
            int connectionId, int accessibilityWindowId, long accessibilityNodeId,
            boolean bypassCache, int prefetchFlags, Bundle arguments) {
        try {
            IAccessibilityServiceConnection connection = getConnection(connectionId);
            if (connection != null) {
                ...
                try {
                     // 尝试binder call到system_server，请求中转到其它APP进程中查询父节点信息，注意的是这里AccessibilityInteractionClient本身是个binder服务端，把this传到system_server后，其它进程可以通过这个引用拿到binder proxy，以实现通信
                    packageNames = connection.findAccessibilityNodeInfoByAccessibilityId(
                            accessibilityWindowId, accessibilityNodeId, interactionId, this,
                            prefetchFlags, Thread.currentThread().getId(), arguments);
                }
                ...
                // 调用成功后，这里会尝试同步获取结果
                ...
            }
            ...
        }
        ...
    }
```

上述的`IAccessibilityServiceConnection`是无障碍服务初始化的时候建立的binder通信管道，是无障碍服务实例向system_server传递信息的桥梁。

同时需要注意的是这里传递了this参数，即`AccessibilityInteractionClient`实例，`AccessibilityInteractionClient`本身是个binder服务端，这是为了通过system_server把binder服务传递给被监控的应用，后续被监控的应用可以直接通过这个链路进行通信。

### AccessibilityServiceConnection#findAccessibilityNodeInfoByAccessibilityId

```java
//frameworks/base/services/accessibility/java/com/android/server/accessibility/AbstractAccessibilityServiceConnection
    public String[] findAccessibilityNodeInfoByAccessibilityId(
            int accessibilityWindowId, long accessibilityNodeId, int interactionId,
            IAccessibilityInteractionConnectionCallback callback, int flags,
            long interrogatingTid, Bundle arguments) throws RemoteException {
        final int resolvedWindowId;
        RemoteAccessibilityConnection connection;
        synchronized (mLock) {
            ...
            connection = mA11yWindowManager.getConnectionLocked(
                    mSystemSupport.getCurrentUserIdLocked(), resolvedWindowId);
            ...
            }
        }
        try {
             // 这里的callback为之前应用的服务proxy句柄，将它传入是为了之后的信息通信不再需要经过system_server中转，而是直接可以APP对APP的进行通信
            connection.getRemote().findAccessibilityNodeInfoByAccessibilityId(
                    accessibilityNodeId, partialInteractiveRegion, interactionId, callback,
                    mFetchFlags | flags, interrogatingPid, interrogatingTid, spec, transformMatrix,
                    arguments);
            return mSecurityPolicy.computeValidReportedPackages(
                    connection.getPackageName(), connection.getUid());
        }
        ...
        return null;
    }
```

`connection.getRemote()`获取的实例是`ViewRootImpl#AccessibilityInteractionConnection`

```java
//frameworks/base/core/java/android/view/ViewRootImpl.java
        @Override
        public void findAccessibilityNodeInfoByAccessibilityId(long accessibilityNodeId,
                Region interactiveRegion, int interactionId,
                IAccessibilityInteractionConnectionCallback callback, int flags,
                int interrogatingPid, long interrogatingTid, MagnificationSpec spec, float[] matrix,
                Bundle args) {
            ViewRootImpl viewRootImpl = mViewRootImpl.get();
            if (viewRootImpl != null && viewRootImpl.mView != null) {
                viewRootImpl.getAccessibilityInteractionController()
                    .findAccessibilityNodeInfoByAccessibilityIdClientThread(accessibilityNodeId,
                            interactiveRegion, interactionId, callback, flags, interrogatingPid,
                            interrogatingTid, spec, matrix, args);
            } else {
                // We cannot make the call and notify the caller so it does not wait.
                try {
                    callback.setFindAccessibilityNodeInfosResult(null, interactionId);
                } catch (RemoteException re) {
                    /* best effort - ignore */
                }
            }
        }
```

```java
//frameworks/base/core/java/android/view/AccessibilityInteractionController.java
    public void findAccessibilityNodeInfoByAccessibilityIdClientThread(
            long accessibilityNodeId, Region interactiveRegion, int interactionId,
            IAccessibilityInteractionConnectionCallback callback, int flags, int interrogatingPid,
            long interrogatingTid, MagnificationSpec spec, float[] matrixValues,
            Bundle arguments) {
        final Message message = mHandler.obtainMessage();
        message.what = PrivateHandler.MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID;
        ...

        synchronized (mLock) {
            ...
            scheduleMessage(message, interrogatingPid, interrogatingTid,
                    CONSIDER_REQUEST_PREPARERS);
        }
    }

    //通过消息传递，进入findAccessibilityNodeInfoByAccessibilityIdUiThread
    private void findAccessibilityNodeInfoByAccessibilityIdUiThread(Message message) {
        ...
                final SatisfiedFindAccessibilityNodeByAccessibilityIdRequest satisfiedRequest =
                        getSatisfiedRequestInPrefetch(requestedNode == null ? null : requestedNode,
                               infos, flags);
                if (satisfiedRequest != null) {
                    returnFindNodeResult(satisfiedRequest);
                }
        ...
    }

    private void returnFindNodeResult(SatisfiedFindAccessibilityNodeByAccessibilityIdRequest
            satisfiedRequest) {
        try {
            final AccessibilityNodeInfo info = satisfiedRequest.mSatisfiedRequestNode;
            final IAccessibilityInteractionConnectionCallback callback =
                    satisfiedRequest.mSatisfiedRequestCallback;
            final int interactionId = satisfiedRequest.mSatisfiedRequestInteractionId;
            callback.setFindAccessibilityNodeInfoResult(info, interactionId);
        } catch (RemoteException re) {
            /* ignore - the other side will time out */
        }
    }

```

### AccessibilityInteractionClient.setFindAccessibilityNodeInfosResult

```java
//frameworks/base/core/java/android/view/accessibility/AccessibilityInteractionClient.java
    public void setFindAccessibilityNodeInfoResult(AccessibilityNodeInfo info,
                int interactionId) {
        synchronized (mInstanceLock) {
            if (interactionId > mInteractionId) {
                mFindAccessibilityNodeInfoResult = info;
                mInteractionId = interactionId;
                mCallingUid = Binder.getCallingUid();
                mCallStackOfCallback = new ArrayList<StackTraceElement>(
                        Arrays.asList(Thread.currentThread().getStackTrace()));
            }
            mInstanceLock.notifyAll();
        }
    }
```

### AccessibilityNodeInfo.findAccessibilityNodeInfosByText

找到父节点信息后，就可以通过父节点获取对应的子节点信息了

```java
//frameworks/base/core/java/android/view/accessibility/AccessibilityNodeInfo.java
    public List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String text) {
        ...
        // 一样的流程，通过AccessibilityInteractionClient去获取信息
        AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
        return client.findAccessibilityNodeInfosByText(mConnectionId, mWindowId, mSourceNodeId,
                text);
    }
```

以下的代码流程同`getRootInActiveWindow`大概一致，就不详细分析了。

## 对目标节点进行操作流程

### AccessibilityNodeInfo.performAction

获取到对应子节点后，通过performAction可以执行对应的操作了，如常用的点击

最终会调用到`AccessibilityInteractionController`，获取到`AccessibilityProvier`后就可以执行`performAction`的最终操作了

```java
//frameworks/base/core/java/android/view/AccessibilityInteractionController.java

    private void performAccessibilityActionUiThread(Message message) {
        ...
        try {
            if (mViewRootImpl.mView == null || mViewRootImpl.mAttachInfo == null ||
                    mViewRootImpl.mStopped || mViewRootImpl.mPausedForTransition) {
                return;
            }
            mViewRootImpl.mAttachInfo.mAccessibilityFetchFlags = flags;
            final View target = findViewByAccessibilityId(accessibilityViewId);
            if (target != null && isShown(target)) {
                mA11yManager.notifyPerformingAction(action);
                if (action == R.id.accessibilityActionClickOnClickableSpan) {
                    // Handle this hidden action separately
                    succeeded = handleClickableSpanActionUiThread(
                            target, virtualDescendantId, arguments);
                } else {
                    AccessibilityNodeProvider provider = target.getAccessibilityNodeProvider();
                    if (provider != null) {
                        succeeded = provider.performAction(virtualDescendantId, action,
                                arguments);
                    } else if (virtualDescendantId == AccessibilityNodeProvider.HOST_VIEW_ID) {
                        succeeded = target.performAccessibilityAction(action, arguments);
                    }
                }
                mA11yManager.notifyPerformingAction(0);
            }
        } finally {
            ...
        }
    }
```

```java
//frameworks/base/core/java/android/view/View.java
    public boolean performAccessibilityAction(int action, @Nullable Bundle arguments) {
      if (mAccessibilityDelegate != null) {
          return mAccessibilityDelegate.performAccessibilityAction(this, action, arguments);
      } else {
          return performAccessibilityActionInternal(action, arguments);
      }
    }
```

最终会调用到`View#performClick`方法

分析到这里可以看到，Accessibility服务框架类似于hook在Android View组件树中的一套实现，它并不是独立的一套机制，而是”寄生”在View的显示、事件分发的流程中。

## 总结

功能实现依赖于ViewRootImpl, ViewGroup, View视图层级管理的基本架构。在视图变化时发出事件、当收到视图操作请求时也能够作出响应。

system_server在实现该功能的过程中扮演着中间人的角色。当被监听APP视图变化时，APP首先会发出事件到system_server，随后再中转到监听者APP端。当监听者APP想要执行视图操作时，也是首先在system_server中找到对应的客户端binder proxy，再调用相应接口调用到被监听APP中。完成相关操作后，通过已经获取到的监听APP binder proxy句柄，直接binder call到对应的监听客户端。

无障碍权限十分重要，切记不可滥用，APP自身也需要有足够的安全意识，防止恶意应用通过该服务获取用户隐私信息。

## 参考

* Make apps more accessible: <https://developer.android.com/guide/topics/ui/accessibility/apps>
* Create your own accessibility service: <https://developer.android.com/guide/topics/ui/accessibility/service>
* 從原始碼角度看AccessibilityService：<https://itw01.com/F4RSQEG.html>
* AccessibilityService分析与防御: <https://lizhaoxuan.github.io/2018/01/27/AccessibilityService%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/>
* Android 9.0源码学习-AccessibilityManager: <https://dufre.blog.csdn.net/article/details/83343312>
