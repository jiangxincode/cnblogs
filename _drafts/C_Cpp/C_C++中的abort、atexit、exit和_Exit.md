这几个函数都在头文件`stdlib.h`中声明。`exit`、`_Exit`与`abort`函数使程序终止，控制并不返回到这些函数的调用者。

## exit函数

```c
void exit(intstate);
```

`exit`函数用于在程序运行的过程中随时结束程序，`exit`的参数`state`是返回给操作系统,返回0表示程序正常结束，非0表示程序非正常结束。`main`函数结束时也会隐式地调用`exit`函数。`exit`函数运行时首先会执行由`atexit`函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流、删除标准I/O函数`tmpfile`创建的临时文件、控制返回宿主环境，提供状态值。

按照许多系统中的习惯，`state`值为0表示终止程序成功，用非0值表示异常终止。标准C语言中数值0和宏EXIT_SCCESS的值表示终止成功，宏EXIT_FAILURE的值表示终止不成功，其他值的含义由实现定义。从函数`main`返回一个整数值相当于用这个值调用`exit`函数。

## _Exit函数

```c
void _Exit(int status);         //C99
```

函数`_Exit`与`exit`函数不同之处在于既不调用`atexit`注册的退出处理器，也不调用`singal`注册的信号处理器。是否进行其他清理操作由实现定义，如关闭所有打开的数据流。`_Exit`是C99增加的，传统上有些实现用名为`_exit`的函数提供类似功能。

## atexit函数

```c
int atexit(void（*func)(void));
```

很多时候我们需要在程序退出的时候做一些诸如释放资源的操作，但程序退出的方式有很多种，比如`main`函数运行结束、在程序的某个地方用`exit`结束程序、用户通过`Ctrl+C`或`Ctrl+break`操作来终止程序等等，因此需要有一种与程序退出方式无关的方法来进行程序退出时的必要处理。方法就是用`atexit`函数来注册程序正常终止时要被调用的函数。

`atexit`函数的参数是一个函数指针，函数指针指向一个没有参数也没有返回值的函数。

在一个程序中最多可以用`atexit`注册32个处理函数，这些处理函数的调用顺序与其注册的顺序相反，也即最先注册的最后调用，最后注册的最先调用。注册函数不能引用任何不是自己定义的存储类为auto或 register的对象（例如通过指针引用）。函数注册几次就会在此时调用几次。

下面是一段代码示例：

```c
#include <stdlib.h>
#include<iostream.h>

void terminateTest()
{
    cout<<"程序正在结束..."<<endl;
}

int main(void)
{
    // 注册退出处理函数
    atexit(terminateTest);
    cout<<"the end ofmain()"<<endl;
    return 0;
}
```

程序的运行结果为：

```shell
the end of main()
程序正在结束...
```

这些函数都是在`main`结束以后才被调用的。`atexit`只是注册他们，使得他们在`main`结束以后被调用，看名字就可以看出来。`atexit`这个玩意超有用，可以按照你预设的顺序摧毁全局变量（类），例如有个log类，你在其它的全局类里也有可能调用到Log类写日志。所以log类必须最后被析构。假如没有规定析构顺序，那么程序在退出时将有可能首先析构log类，那么其它的全局类在此时将无法正确写日志。


## abort函数

```c
void abort(void);
```

`abort`函数使程序异常终止，不调用向`atexit`注册的函数。`abort`是否引起清理操作由实现定义，向宿主系统返回的状态值也由实现定义，但应表示为“不成功”。在标准C语言和许多传统实现中，调用`abort`转换成可以捕获的特殊信号（标准C语言中为`SIGABRT`）。如果信号被忽略或处理器返回，则标准C语言实现仍然终止程序，而其他实现可能使`abort`函数返回调用者。断言失败也会调用`abort`。
